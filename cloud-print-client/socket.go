package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"sync"
	"time"

	"github.com/gorilla/websocket"
)

// AuthMessage defines the structure of the authentication message for server-side verification
type AuthMessage struct {
	Type          string `json:"type"`           // Message type (e.g., "auth")
	Token         string `json:"token"`          // Unique token generated by the client
	Processor     string `json:"processor"`      // Machine's processor details
	Platform      string `json:"platform"`       // Machine's platform details (e.g., OS)
	HardwareID    string `json:"hardware_id"`    // Unique hardware identifier
	ClientVersion string `json:"client_version"` // Client Software Version
}

type PrintCommand struct {
	PrinterID        string  `json:"printer_id"`
	JobName          string  `json:"job_name"`
	JobType          string  `json:"job_type"`
	PrintOrientation string  `json:"print_orientation"`
	JobID            string  `json:"job_id"`
	JobToken         string  `json:"job_token"`
	Command          string  `json:"command"`
	Width            float64 `json:"width"`
	Height           float64 `json:"height"`
	Unit             string  `json:"unit"`
	Barcode          string  `json:"barcode"`
	Mashul           string  `json:"mashul"`
	Weight           string  `json:"weight"`
}

type OutGoingLog struct {
	JobID   string `json:"JobId"`
	Event   string `json:"Event"`
	Message string `json:"Message"`
}

var (
	// socketURL = "wss://ekdak.com/ekdak-cloud-print-subscriber" // WebSocket server URL
	socketURL = appSettings.SOCKET_URL // WebSocket server URL
)

// Create a buffered channel for outgoing messages
var outgoingMessages = make(chan interface{}, 1000) // Adjust buffer size as needed
// Mutex for safe access to the WebSocket connection
var connMutex sync.Mutex
var conn *websocket.Conn

func connectWebSocket(console *Console, printManager *PrintManager, authMessage *AuthMessage) {
	for {
		// Attempt to connect to WebSocket server
		var err error
		connMutex.Lock()
		conn, _, err = websocket.DefaultDialer.Dial(socketURL, nil)
		connMutex.Unlock()

		if err != nil {
			console.MsgChan <- Message{
				Text:  fmt.Sprintf("Connection failed, retrying in 2 seconds: %s", err),
				Color: colorNRGBA(255, 40, 0, 255), // Red
			}
			time.Sleep(2 * time.Second)
			continue
		}

		log.Println("WebSocket connection established")
		console.MsgChan <- Message{
			Text:  "Server connection established",
			Color: colorNRGBA(255, 140, 0, 255),
		}

		// Authenticate immediately
		if err := sendJSON(authMessage); err != nil {
			console.MsgChan <- Message{
				Text:  fmt.Sprintf("Auth failed, reconnecting: %v", err),
				Color: colorNRGBA(255, 40, 0, 255),
			}
			conn.Close()
			time.Sleep(2 * time.Second)
			continue
		}

		// Start message receiver
		receiveMessages(console, printManager)

		// If receiveMessages exits, the connection is lost
		console.MsgChan <- Message{
			Text:  "Connection lost, reconnecting...",
			Color: colorNRGBA(255, 40, 0, 255),
		}
		time.Sleep(2 * time.Second)
	}
}

// sendMessageWorker sends messages in the queue while handling errors.
func sendMessageWorker(console *Console) {
	time.Sleep(5 * time.Second) // Wait for the connection to be established
	for msg := range outgoingMessages {
		if err := sendJSON(msg); err != nil {
			console.MsgChan <- Message{
				Text:  fmt.Sprintf("Failed to send message, requeuing: %v", err),
				Color: colorNRGBA(255, 40, 0, 255), // Red
			}
			time.Sleep(1 * time.Second)
			requeueMessage(msg)

		}
	}
}

// sendJSON safely sends JSON data over the WebSocket connection
func sendJSON(data interface{}) error {
	connMutex.Lock()
	defer connMutex.Unlock()

	if conn == nil {
		return fmt.Errorf("no active connection")
	}

	return conn.WriteJSON(data)
}

// requeueMessage places the message back in the queue for retry
func requeueMessage(msg interface{}) {
	select {
	case outgoingMessages <- msg:
		log.Println("Message requeued successfully")
	default:
		log.Println("Message queue full, dropping message")
	}
}

// receiveMessages listens for messages from the server
func receiveMessages(console *Console, printManager *PrintManager) {
	for {
		_, message, err := conn.ReadMessage()
		if err != nil {
			console.MsgChan <- Message{
				Text:  fmt.Sprintf("Connection lost: %v", err),
				Color: colorNRGBA(255, 40, 0, 255), // Red
			}
			conn.Close()
			break
		}

		var printCommand PrintCommand
		if err := json.Unmarshal(message, &printCommand); err != nil {
			log.Println("Error parsing JSON:", err)
			continue
		}

		handlePrintCommand(console, printManager, &printCommand)
	}
}

// handlePrintCommand processes incoming commands
func handlePrintCommand(console *Console, printManager *PrintManager, printCommand *PrintCommand) {
	switch printCommand.Command {
	case "specimen-print":
		console.MsgChan <- Message{
			Text:  fmt.Sprintf("Specimen Printing job %s", printCommand.JobID),
			Color: colorNRGBA(255, 140, 0, 255),
		}
		go SpecimenPrint(console, printManager, printCommand)

	case "test-print":
		console.MsgChan <- Message{
			Text:  fmt.Sprintf("Test Printing job %s", printCommand.Command),
			Color: colorNRGBA(255, 140, 0, 255),
		}
		go testPrint(console, printManager, printCommand)

	case "live-print":
		console.MsgChan <- Message{
			Text:  fmt.Sprintf("Live Printing job %s", printCommand.JobID),
			Color: colorNRGBA(255, 140, 0, 255),
		}
		go LivePrint(console, printManager, printCommand)

	case "pong":
		console.MsgChan <- Message{
			Text:  "Pong Received",
			Color: colorNRGBA(255, 140, 0, 255),
		}
	}
}

// getHardwareID retrieves a unique hardware identifier based on the OS
func getHardwareID() (string, error) {
	switch runtime.GOOS {
	case "windows":
		return getWindowsHardwareID()
	case "linux":
		return getLinuxHardwareID()
	case "darwin":
		return getMacHardwareID()
	default:
		return "", fmt.Errorf("unsupported OS: %s", runtime.GOOS)
	}
}
func getWindowsHardwareID() (string, error) {
	// Try WMIC first
	uuid, err := getUUIDByWMIC()
	if err == nil {
		return uuid, nil
	}

	// WMIC failed, try PowerShell fallback
	uuid, err = getUUIDByPowerShell()
	if err != nil {
		return "", fmt.Errorf("failed to get UUID by WMIC (%v) and PowerShell (%v)", err, err)
	}

	return uuid, nil
}

func getUUIDByWMIC() (string, error) {
	cmd := exec.Command("wmic", "csproduct", "get", "UUID")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to execute WMIC command: %w", err)
	}

	lines := strings.Split(strings.TrimSpace(string(output)), "\n")
	if len(lines) < 2 {
		return "", fmt.Errorf("unexpected WMIC output format")
	}

	uuid := strings.TrimSpace(lines[1])
	if uuid == "" || uuid == "00000000-0000-0000-0000-000000000000" {
		return "", fmt.Errorf("invalid UUID retrieved from WMIC")
	}

	return uuid, nil
}

func getUUIDByPowerShell() (string, error) {
	cmd := exec.Command("powershell", "-Command",
		"Get-CimInstance -ClassName Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID")

	var out bytes.Buffer
	cmd.Stdout = &out

	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("failed to execute PowerShell command: %w", err)
	}

	uuid := strings.TrimSpace(out.String())
	if uuid == "" || uuid == "00000000-0000-0000-0000-000000000000" {
		return "", fmt.Errorf("invalid UUID retrieved from PowerShell")
	}

	return uuid, nil
}

// getLinuxHardwareID retrieves the hardware ID on Linux by reading system files
func getLinuxHardwareID() (string, error) {
	// Attempt to read the system UUID from /sys/class/dmi/id/product_uuid
	filePath := "/sys/class/dmi/id/product_uuid"
	data, err := os.ReadFile(filePath)
	if err == nil {
		uuid := strings.TrimSpace(string(data))
		if uuid != "" && uuid != "00000000-0000-0000-0000-000000000000" {
			return uuid, nil
		}
	}

	// Fallback: Attempt to use dmidecode (requires root)
	cmd := exec.Command("dmidecode", "-s", "system-uuid")
	output, err := cmd.Output()
	if err == nil {
		uuid := strings.TrimSpace(string(output))
		if uuid != "" && uuid != "00000000-0000-0000-0000-000000000000" {
			return uuid, nil
		}
	}

	return "", fmt.Errorf("failed to retrieve hardware ID on Linux")
}

// getMacHardwareID retrieves the hardware ID on macOS using ioreg
func getMacHardwareID() (string, error) {
	// Execute the ioreg command to get the IOPlatformUUID
	cmd := exec.Command("ioreg", "-rd1", "-c", "IOPlatformExpertDevice")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to execute ioreg command: %w", err)
	}

	// Parse the output to find IOPlatformUUID
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.Contains(line, "IOPlatformUUID") {
			parts := strings.Split(line, "=")
			if len(parts) == 2 {
				uuid := strings.Trim(strings.TrimSpace(parts[1]), "\"")
				if uuid != "" && uuid != "00000000-0000-0000-0000-000000000000" {
					return uuid, nil
				}
			}
		}
	}

	return "", fmt.Errorf("failed to retrieve hardware ID on macOS")
}

// GenerateAuthMessage creates an AuthMessage based on machine details and the public key
func GenerateAuthMessage() (*AuthMessage, error) {
	// Fetch the public key
	// publicKeyURL := PUBLIC_KEY_URL
	// if publicKeyURL == "" {
	// 	return nil, fmt.Errorf("PUBLIC_KEY_URL environment variable is not set")
	// }

	// Collect machine-specific details
	processor := runtime.GOARCH        // e.g., "amd64", "arm64"
	platform := runtime.GOOS           // e.g., "windows", "linux", "darwin"
	hardwareID, err := getHardwareID() // Unique hardware identifier
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve hardware ID: %w", err)
	}

	// log.Println("Retrieved hardware ID:", hardwareID)

	// Combine details with the public key to generate the unique ID
	data := processor + platform + hardwareID
	hash := sha256.Sum256([]byte(data))
	clientID := hex.EncodeToString(hash[:])
	// log.Println("Generated client ID:", clientID)

	// For infinite validity, set Token as ClientID
	token := clientID[3:8] + clientID[16:21] + clientID[32:37] + clientID[48:51]
	// log.Println("Generated token:", token)

	// Create the AuthMessage
	authMessage := &AuthMessage{
		Type:          "auth",       // Set type as "auth"
		Token:         token,        // Unique token (same as ClientID)
		Processor:     processor,    // Processor details
		Platform:      platform,     // Platform details
		HardwareID:    hardwareID,   // Hardware identifier
		ClientVersion: getVersion(), // Client Software Version
	}

	return authMessage, nil
}

func PingPong() {
	for {
		outgoingMessages <- OutGoingLog{JobID: "ping", Event: "ping", Message: "ping"}
		time.Sleep(75 * time.Second)
	}
}
